<?xml version="1.0" encoding="UTF-8"?>
<feed xmlns="http://www.w3.org/2005/Atom" xml:lang="en">
    <title>Hashpool - Development Logs</title>
    <link rel="self" type="application/atom+xml" href="https://hashpool.dev/dev-logs/atom.xml"/>
    <link rel="alternate" type="text/html" href="https://hashpool.dev/dev-logs/"/>
    <generator uri="https://www.getzola.org/">Zola</generator>
    <updated>2025-04-05T00:00:00+00:00</updated>
    <id>https://hashpool.dev/dev-logs/atom.xml</id>
    <entry xml:lang="en">
        <title>Build Me Up a Quote System Buttercup</title>
        <published>2025-04-05T00:00:00+00:00</published>
        <updated>2025-04-05T00:00:00+00:00</updated>
        
        <author>
          <name>
            
              vnprc
            
          </name>
        </author>
        
        <link rel="alternate" type="text/html" href="https://hashpool.dev/dev-logs/dev-log-2025-04-05/"/>
        <id>https://hashpool.dev/dev-logs/dev-log-2025-04-05/</id>
        
        <content type="html" xml:base="https://hashpool.dev/dev-logs/dev-log-2025-04-05/">&lt;h2 id=&quot;2025-year-of-the-linux-desktop-laptop&quot;&gt;2025: Year of the Linux &lt;del&gt;Desktop&lt;&#x2F;del&gt; Laptop&lt;&#x2F;h2&gt;
&lt;p&gt;I migrated to a new linux dev machine. I have bounced between linux and Mac many times in the past. Previously, when I went back to Mac the deciding factor was poor linux support for laptop hardware and corporate software I was required to run. Last year I quit the corporate world forever, so the balance has shifted.&lt;&#x2F;p&gt;
&lt;p&gt;It seems like linux hardware support gets better every year while Mac hardware and (most infuriating) OS level software restrictions continue to enshittify year after year. It feels good to break free. GFY Apple. ü§ìüñïüçè&lt;&#x2F;p&gt;
&lt;h2 id=&quot;build-issues&quot;&gt;Build Issues&lt;&#x2F;h2&gt;
&lt;p&gt;When I tried to run Hashpool on linux for the first time the bitcoind process failed to build. After troubleshooting I realized that I was referencing an old commit on sjors&#x27; bitcoind branch that has since been orphaned by a force push. The build cache has been insulating me from build failures all these months. A CI system would catch these failures, but it&#x27;s not a problem unless you have a team of people working on the same codebase. Squad goals.&lt;&#x2F;p&gt;
&lt;p&gt;I updated my bitcoind branch to the latest revision and got Hashpool running again. When you encounter a build issue that&#x27;s likely to reoccur it&#x27;s always a good idea to try and find a permanent fix. So I turned my attention to the build system. At the beginning of this process I had a very limited understanding of nix, devenv, and nix flakes. But I knew that flakes are good for locking down your dependencies so I forged onward in an attempt to do exactly that.&lt;&#x2F;p&gt;
&lt;p&gt;I spent a few days vibe coding a nix flake. After much struggle and frustration, I actually got it to build. Unfortunately, I quickly realized that this was not a solution to my problem. As for vibe coding a nix flake, I do not recommend this path to other developers. üòÖ Probably better to stick to vibe coding the frontend.&lt;&#x2F;p&gt;
&lt;p&gt;I can&#x27;t use a nix flake to track sjors&#x27; branch because his repo is not a flake itself. Sjors would need to commit a &lt;code&gt;flake.nix&lt;&#x2F;code&gt; file to his repo, and keep it up to date. In light of this new information I opted to manually keep track of the bitcoind revision and write a just recipe to assist with the process of updating it.&lt;&#x2F;p&gt;
&lt;p&gt;When I was satisfied with the new solution I deleted the flake file. I will definitely be using flakes in the future so it&#x27;s only a matter of time before I bring &lt;code&gt;flake.nix&lt;&#x2F;code&gt; back but I will wait until the need arises.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;logging&quot;&gt;Logging&lt;&#x2F;h2&gt;
&lt;p&gt;When I was troubleshooting the linux build I opened a &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;stratum-mining&#x2F;stratum&#x2F;issues&#x2F;1559&quot;&gt;PR&lt;&#x2F;a&gt; to the SRI repo with my log errors. If you look at the issue you can see I only included screenshots of my logs. This is because devenv processes only output to the console. I don&#x27;t know if or how you can copy text out of the &lt;code&gt;devenv up&lt;&#x2F;code&gt; terminal environment so screenshots were all I had. It was good enough to get the job done in this case but far from optimal. After this experience I decided that logging was a top priority.&lt;&#x2F;p&gt;
&lt;p&gt;I updated my &lt;code&gt;devenv.nix&lt;&#x2F;code&gt; file to get output logs working for all processes. These logs will be essential to troubleshoot issues in the future, guaranteed.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;version-0-1&quot;&gt;Version 0.1&lt;&#x2F;h2&gt;
&lt;p&gt;With a new computer and new, hard won build expertise I was ready to refactor. One of the first things I wanted to do was to rip out the proof generation from Hashpool. The new quote design completely removes the need to handle this function in the SRI code.&lt;&#x2F;p&gt;
&lt;p&gt;I tagged Hashpool v0.1 to keep a reference to the first working ehash implementation. I had a feeling I would want to refer to this code in the future and the change in development direction seemed like a good reason to drop a tag. I didn&#x27;t tell anybody because it was kind of a nothingburger development. But, to my surprise, Bitcoin Optech &lt;a href=&quot;https:&#x2F;&#x2F;bitcoinops.org&#x2F;en&#x2F;newsletters&#x2F;2025&#x2F;03&#x2F;21&#x2F;#hashpool-v0-1-tagged&quot;&gt;picked it up&lt;&#x2F;a&gt;! üò≥ Do you ever feel watched?&lt;&#x2F;p&gt;
&lt;p&gt;I have never run an open source project before so I don&#x27;t know if or what proper versioning etiquette is. This release has no build artifacts, no instructions, no release notes, and thanks to the lack of a nix flake it probably won&#x27;t work at all very soon. Fortunately, none of these things is a problem if you don&#x27;t have any developers or users. But hey, the first version was tagged so let&#x27;s party! üéâ&lt;&#x2F;p&gt;
&lt;h2 id=&quot;mint-quotes&quot;&gt;Mint Quotes&lt;&#x2F;h2&gt;
&lt;p&gt;When I finally started working on quotes (a few weeks after identifying the need) I found it simple and straightforward to &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;cashubtc&#x2F;cdk&#x2F;commit&#x2F;209dfe942595b5fc27065ae2db3ca4aad7d3247b&quot;&gt;add a new quote type&lt;&#x2F;a&gt; to my cdk fork, and in a hashpool &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;vnprc&#x2F;hashpool&#x2F;commit&#x2F;c0868831187b40647d59fa8a3948b84e9219773c&quot;&gt;commit&lt;&#x2F;a&gt; replace the proof generation with quote generation and return the &lt;code&gt;quote_id&lt;&#x2F;code&gt;.&lt;&#x2F;p&gt;
&lt;p&gt;&lt;a href=&quot;&#x2F;images&#x2F;dev-logs&#x2F;cool-cool-cool.gif&quot;&gt;Cool cool cool&lt;&#x2F;a&gt;. So it runs and logs a quote id, but how do I test the quote system? The idea is to have the user wallet poll the mint and retrieve tokens when the quote status is updated to &lt;code&gt;PAID&lt;&#x2F;code&gt;. How do I do this with the current design?&lt;&#x2F;p&gt;
&lt;p&gt;Well, I can&#x27;t really. The mint is just some cdk code hacked in to the pool role. It doesn&#x27;t have an http api (at least I hope not!) because SRI has its own whole communication protocol. Bolting on a cashu mint would muddy the waters and explode the complexity of building and supporting this system.&lt;&#x2F;p&gt;
&lt;p&gt;Running a separate process is a much better design because it separates the Sv2 and cashu protocols with a minimal interface between them. This way, if the mint has a bug it won&#x27;t interfere with mining operations and if the pool process has an issue it won&#x27;t interfere with ecash operations.&lt;&#x2F;p&gt;
&lt;p&gt;Also, decoupling these processes will enable operators to deploy and scale them as needed. The load profile of mining and ecash operations will differ. They will experience load spikes at different times and with different magnitudes. Plus, developers can specialize around the different roles. Personally, I expect to do more work in the mint than the mining side of the stack.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;mint-service&quot;&gt;Mint Service&lt;&#x2F;h2&gt;
&lt;p&gt;I stood up a standalone mint service as a devenv process. This was more difficult than I anticipated due to dependency issues between cdk and SRI. I eventually found that by using nightly rust I could enforce a consistent rust version between SRI and cdk. This was a quick and dirty solution that let me move forward but I think it highlights the need for a nix flake.&lt;&#x2F;p&gt;
&lt;p&gt;I understand the &#x27;right&#x27; way to force a rust version is to use a nix flake. I was able to find a workaround but nightly rust is unstable and will eventually come back to haunt me. This makes me wonder when is the right time to bring the flake back?&lt;&#x2F;p&gt;
&lt;p&gt;I haven&#x27;t updated my SRI code in quite a while. I need to check if more recent SRI and&#x2F;or cdk releases can resolve some of the dependency issues I encountered. I am hesitant to update SRI while the ecash code is in flux. And I don&#x27;t want to slow Hashpool development any further to spend more time on the build system. I could have the best damn build system in the world but what good is it if I still don&#x27;t have a working mining pool?&lt;&#x2F;p&gt;
&lt;p&gt;In the back of my mind I am questioning what the best order of operations will be. My overarching goal is to sprint to a working implementation of an eHash mining pool. When issuance is working I will migrate to a nix flake and iron out my dependencies. With flake in hand, I can update to the latest SRI release and pin that version. We&#x27;ll see how accurate this plan is in the coming months.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;cdk-clis&quot;&gt;cdk CLIs&lt;&#x2F;h2&gt;
&lt;p&gt;A big part of my struggle with the build system was trying to get the cdk cli binaries to build as part of the development environment. I thrashed around for a while on this problem and finally just committed the binaries directly. This is not ideal because it adds an extra step every time you update the cdk code. If that update breaks either CLI binary you need to recompile it and re-commit. So it&#x27;s an infrequent update that is usually not required. A recipe for breakage.&lt;&#x2F;p&gt;
&lt;p&gt;Again, I prioritized expediency. This isn&#x27;t a problem worth spending a lot of time on and it can be resolved when I nail down my dependencies with a nix flake. In my engineering career I have found that quick little hacks like this either have a very short lifespan or they last a shockingly long time. There aren&#x27;t really a lot of hacks that last a medium length of time. I have a feeling this is one of the latter cases because it&#x27;s so darn easy to just copy a new binary over and commit it.&lt;&#x2F;p&gt;
&lt;p&gt;With the CLIs ready to go I can now query the mint process for quotes to test that functionality when it&#x27;s ready.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;next-step-redis-queue&quot;&gt;Next Step: Redis Queue&lt;&#x2F;h2&gt;
&lt;p&gt;At first I intended to build a gRPC messaging layer between the pool and mint processes. When I started planning this I realized once again that I would have to reconcile the different async models of SRI and cdk. SRI uses the MPSC model and CDK uses tokio for async operations. I&#x27;m not really familiar with these models or how to reconcile them between processes but it looks like tokio has an MPSC channel for this purpose.&lt;&#x2F;p&gt;
&lt;p&gt;I don&#x27;t think I need to go there, though. I will also need to queue requests at the mint to protect against a load spike. Pooled mining is a very time sensitive operation. Milliseconds count, so the last thing I want to do is slow down the mining services to wait on the less time sensitive ecash operations.&lt;&#x2F;p&gt;
&lt;p&gt;When I thought about it for a bit I realized that none of the mint operations need to happen synchronously. This means I can skip the gRPC messaging layer entirely and rely on redis for all communications. I only need two message types: create quote, called when a mining share is accepted; and update quote, called when the pool is ready for the mint to release the ecash tokens. In Hashpool, update quote events will be fired when the share and block template are both validated.&lt;&#x2F;p&gt;
&lt;p&gt;In Axepool, update quote will be fired when the pool payout lands and the user is able to redeem their sats from the mint. The fact that the same architecture works equally well for two totally different pool designs is a big hint that we have arrived at the correct abstraction. Big props to team cashu for figuring out the hard stuff and capturing it in a specification! Y&#x27;all are the goats of NUTs (not to be confused with the goats&#x27; nuts).&lt;&#x2F;p&gt;
&lt;p&gt;Wait...did you say Axepool? WTF is Axepool?&lt;&#x2F;p&gt;
&lt;h2 id=&quot;axepool&quot;&gt;Axepool&lt;&#x2F;h2&gt;
&lt;p&gt;One of the goals of Hashpool from the beginning was to enable a proxy pool. I do not mean this term in the same way that people refer to a small pool mining on the same template as a larger pool. When I say proxy pool I am referring to a mining pool built on a stratum proxy server.&lt;&#x2F;p&gt;
&lt;p&gt;This is a pool that mines upstream to another pool. It&#x27;s not a widely understood concept yet because no one has built one before but I believe this is the future of mining. I plan to talk about this idea at length at btc++ Austin in May of this year. Check out my &lt;a href=&quot;https:&#x2F;&#x2F;btcplusplus.dev&#x2F;conf&#x2F;atx25&#x2F;talks#atx_proxy&quot;&gt;talk&lt;&#x2F;a&gt; to learn more of the theory behind this idea.&lt;&#x2F;p&gt;
&lt;p&gt;Hashpool today is not a proxy pool. When discussing these ideas with friends, I explained how the only realistic path to build a proxy pool today is with OCEAN because they are the only PPLNS pool left standing. All we need to build it is an Sv1 proxy with the right callback hooks to perform ecash operations. After this conversation, my pal Johnny decided to go out and build it.&lt;&#x2F;p&gt;
&lt;p&gt;What a chad! Johnny gets it. We must accelerate. He&#x27;s developing a minimal Sv1 proxy with the goal of enabling ecash mining pool withdrawals as soon as possible.&lt;&#x2F;p&gt;
&lt;p&gt;It&#x27;s called Axepool because we are targeting the Bitaxe market. Bitaxe runners today mostly solo mine because the user experience of existing pools is terrible for micro miners. Axepool&#x27;s primary goal is to accelerate the adoption of pleb mining by solving this UX challenge. We&#x27;re going to skip over eHash and build the design described &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;plebemineira&#x2F;plebpool&#x2F;discussions&#x2F;7#discussioncomment-9214022&quot;&gt;here&lt;&#x2F;a&gt; which enables users to mine privately and withdraw to an ecash wallet.&lt;&#x2F;p&gt;
&lt;p&gt;A big benefit of this design is that redemptions are super simple. Instead of rotating the ecash epoch on a clock time schedule in order to enforce PPLNS share accounting, we can just have one ecash epoch per OCEAN block. Axepool can simply sum all shares received in between OCEAN blocks and pay them out as soon as the payout hits the Axepool lightning node. All we need is a BOLT12 callback to trigger the quote update message.&lt;&#x2F;p&gt;
&lt;p&gt;The reason this is possible is that OCEAN implements TIDES (modified PPLNS) at the pool level so we don&#x27;t need to reimplement it again at the proxy level. We can piggy back on TIDES to smooth out the Axepool payout structure across blocks.&lt;&#x2F;p&gt;
&lt;p&gt;Axepool development will happen in parallel with Hashpool. It will reuse the quote based ecash design and have a drastically simplified payout system with no intermediate eHash asset. Users will submit mining shares and wait for the next OCEAN block to sweep their ecash tokens from the mint.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;hrf-grant&quot;&gt;HRF Grant&lt;&#x2F;h2&gt;
&lt;p&gt;HRF has &lt;a href=&quot;https:&#x2F;&#x2F;hrf.org&#x2F;latest&#x2F;hrf-bitcoin-development-fund-supports-20-projects-worldwide&#x2F;&quot;&gt;awarded me a grant&lt;&#x2F;a&gt; for Hashpool development! Holla!&lt;&#x2F;p&gt;
&lt;p&gt;Someone decided to pay me to write open source code. That means I am now a professional open source developer. This should leave you feeling very confident about the future of bitcoin mining.&lt;&#x2F;p&gt;
&lt;p&gt;&lt;img src=&quot;&#x2F;images&#x2F;dev-logs&#x2F;im-in-danger.jpg&quot; alt=&quot;I&amp;#39;m in danger&quot; &#x2F;&gt;&lt;&#x2F;p&gt;
</content>
        
    </entry>
    <entry xml:lang="en">
        <title>NEMS, Website, and Issue Tracking</title>
        <published>2025-03-03T00:00:00+00:00</published>
        <updated>2025-03-03T00:00:00+00:00</updated>
        
        <author>
          <name>
            
              vnprc
            
          </name>
        </author>
        
        <link rel="alternate" type="text/html" href="https://hashpool.dev/dev-logs/dev-log-2025-03-03/"/>
        <id>https://hashpool.dev/dev-logs/dev-log-2025-03-03/</id>
        
        <content type="html" xml:base="https://hashpool.dev/dev-logs/dev-log-2025-03-03/">&lt;h2 id=&quot;socratic-of-hard-knocks&quot;&gt;Socratic of Hard Knocks&lt;&#x2F;h2&gt;
&lt;p&gt;I was invited to attend the Nashville Energy and Mining Summit (NEMS) at Bitcoin Park Jan 30th and 31st. This would be a great opportunity to talk with miners to spread the word and get feedback on my project.&lt;&#x2F;p&gt;
&lt;p&gt;The day before the conference I presented my project at BitDevs. It went horribly. I was planning to demo my project live but of course the demonstration gods picked that exact time to smite me with a build error. It totally threw me off my game. I tried to fumble through an explanation and troubleshoot the build error at the same time and ended up failing at both.&lt;&#x2F;p&gt;
&lt;p&gt;It wasn&#x27;t a total loss. The audience was genuinely interested in the project and had good questions. I did manage to explain a few concepts, just not very well and not in a way that told a story. Instead it was kind of a jumble of ideas. The rest of the socratic seminar went great and I was able to contribute to the discussion.&lt;&#x2F;p&gt;
&lt;p&gt;In retrospect, the demo wasn&#x27;t even important. I was just counting on it to have something for the audience to look at while I talked. I should have been mentally preparing to explain the project but instead I was totally focused on the unimportant thing and when it failed I was not able to recover. It&#x27;s not a lesson I will soon forget.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;telehash-and-grants&quot;&gt;Telehash and Grants&lt;&#x2F;h2&gt;
&lt;p&gt;The rest of the conference went really well. The following day I was invited on stage during the Telehash to talk about Hashpool. This time I elected to skip the demo and just explain the project. It went much better! The beginning got cut off but you can watch the recording in this &lt;a href=&quot;https:&#x2F;&#x2F;x.com&#x2F;bitcoinpark_&#x2F;status&#x2F;1884708999154852093&quot;&gt;twitter post&lt;&#x2F;a&gt;.&lt;&#x2F;p&gt;
&lt;p&gt;The 256 Foundation also announced a few grants including one that seems to closely match Hashpool. They are calling it &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;The-256-Foundation&#x2F;Hydra-Pool-website&quot;&gt;Hydrapool&lt;&#x2F;a&gt; and the idea is to have an easily deployable mining pool. Very similar to my layered mining pool concept!&lt;&#x2F;p&gt;
&lt;p&gt;In the weeks since the conference I have been considering an application and I have a few concerns. The grant description lists a team of 2 - 5. Do I need a team to apply? Do they have funding for a team? Also, I&#x27;m not an OSS licensing expert but it seems that my project&#x27;s inherited MIT license might make it incompatible since &lt;a href=&quot;https:&#x2F;&#x2F;x.com&#x2F;econoalchemist&#x2F;status&#x2F;1890071218486915396&quot;&gt;256 Foundation asks for GPL3.0&lt;&#x2F;a&gt;.&lt;&#x2F;p&gt;
&lt;p&gt;My uncertainty around these questions has prevented me from applying for the grant. I still have open applications to Spiral and HRF and I am hopeful that one of them will come through. I&#x27;m also cognizant that I will need to attract developers for my project to succeed, and they will need to get paid for their work. Gary applied independently for the 256 grant and it seems to be going well. The best outcome is if we both receive grants and can both dedicate more time to the project so I have opted to take a wait and see approach with my outstanding grants.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;nems&quot;&gt;NEMS&lt;&#x2F;h2&gt;
&lt;p&gt;Once the conference properly began something kicked in and I went into high activity mode. I talked to everyone I could about mining, ecash, Hashpool, and other projects.&lt;&#x2F;p&gt;
&lt;p&gt;Cashu.me, the new PWA cashu wallet, made onboarding people as easy as cake. It really demonstrates the ease of use that the cashu protocol enables.&lt;&#x2F;p&gt;
&lt;p&gt;Pitching Hashpool requires explaining 3 or 4 new concepts to people. Starting with the user flow is key. Knowing the perspective of the person you are pitching to is also key. The pitch for professional miners is different from the pitch for hobbyist miners.&lt;&#x2F;p&gt;
&lt;p&gt;The fact that ecash is an old technology seeing a renaissance really resonates with people. Banking analogies work quite well to explain the concepts. Talking about free banking seems to combine these effects. Great intel! I will keep refining my message.&lt;&#x2F;p&gt;
&lt;p&gt;I also pitched Hashpool to the CEO of Foundry, he said it was a really good idea. Later I ecash pilled the president of OCEAN mining and set up a meeting to discuss Hashpool with their technical folks. I think I am starting to get on people&#x27;s radar!&lt;&#x2F;p&gt;
&lt;h2 id=&quot;project-tracking&quot;&gt;Project Tracking&lt;&#x2F;h2&gt;
&lt;p&gt;Gary created a &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;users&#x2F;vnprc&#x2F;projects&#x2F;2&quot;&gt;KanBan board&lt;&#x2F;a&gt; and added a the first &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;vnprc&#x2F;hashpool&#x2F;issues&quot;&gt;Hashpool issues&lt;&#x2F;a&gt; to it. I spent a few days going hard and filled out the board with about 20 issues. It was honestly a little demotivating to see all the work that needs doing but at the same time it was good to unload all of that context from my brain to free up CPU cycles for other things. Once I started making progress on those issues the demotivating factor went away.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;cdk-pr&quot;&gt;CDK PR&lt;&#x2F;h2&gt;
&lt;p&gt;Once I was able to get back into the code I brought my cdk fork up to the latest release. I actually created a new branch and reapplied my changes when the rebase got too tricky but the end result is the same.&lt;&#x2F;p&gt;
&lt;p&gt;Next I opened a &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;cashubtc&#x2F;cdk&#x2F;pull&#x2F;605&quot;&gt;draft PR&lt;&#x2F;a&gt; to discuss my changes. There are still some todo items to finish but I wanted to get feedback on my general direction of development.&lt;&#x2F;p&gt;
&lt;p&gt;We discussed the PR at a cdk meeting and I came away with a new and different development plan. I need to refactor my design to return the quote ID in the share accepted message instead of the blind signatures. This change simplifies the design quite a bit and lets me delete 1&#x2F;3rd of the message flows I have already developed. Nice!&lt;&#x2F;p&gt;
&lt;p&gt;Currently on startup, Hashpool retrieves the keyset from the upstream pool. Then on share submission the proxy service sends blinded messages upstream to the pool, who sends the blinded signatures back downstream to the proxy to assemble into proofs, or ecash tokens.&lt;&#x2F;p&gt;
&lt;p&gt;With the new flow I don&#x27;t need to send the blinded signatures back to the mining proxy service. Instead, the mint will produce the signatures asynchronously and the user wallet can retrieve them from the mint using the standard &lt;a href=&quot;https:&#x2F;&#x2F;cashubtc.github.io&#x2F;nuts&#x2F;04&#x2F;&quot;&gt;NUT-04&lt;&#x2F;a&gt; and &lt;a href=&quot;https:&#x2F;&#x2F;cashubtc.github.io&#x2F;nuts&#x2F;20&#x2F;&quot;&gt;NUT-20&lt;&#x2F;a&gt; protocols. This means less code for me to write and maintain, less surface area interaction between the ecash and mining protocols, and it solves two problems for me.&lt;&#x2F;p&gt;
&lt;p&gt;In the old design I needed a way to get the ecash tokens off of the proxy service and into the user wallet. I was planning to implement NIP-60 and upload the proofs to a nostr relay. With the new design I simply use the mint as the staging area instead of adding a new service to fill that role. This takes NIP-60 off the critical path of development and lets me tap into existing (and already implemented) wallet flows to solve my problem.&lt;&#x2F;p&gt;
&lt;p&gt;The other problem has to do with block invalidation. Sometimes when a user submits their own block template the pool can invalidate that share some time after accepting it because they find the block template invalid in some way. In an accountless ecash system you can&#x27;t invalidate an ecash token after it has been issued. Invalidating only the share but not the token issued in exchange for it would inflate the token supply.&lt;&#x2F;p&gt;
&lt;p&gt;So we need a way to withhold the signatures until the share is fully validated. What a coinky dink! The cashu protocol developers already solved this problem with their quote system. This &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;cashubtc&#x2F;cdk&#x2F;pull&#x2F;605#issuecomment-2669117208&quot;&gt;new design&lt;&#x2F;a&gt; decouples minting ecash from the mining protocol messages. The pool can hold the blinded secrets as long as needed (potentially for a whole ecash epoch) to validate the user submitted block templates.&lt;&#x2F;p&gt;
&lt;p&gt;I don&#x27;t plan to launch with user selected block templates but I do see it as a very important feature. Designing for it now will save me a big headache later on down the line.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;passphrase-magazine-and-hashpool-dev&quot;&gt;Passphrase Magazine and hashpool.dev&lt;&#x2F;h2&gt;
&lt;p&gt;After my presentation at btc++ I was approached by the editor of &lt;a href=&quot;https:&#x2F;&#x2F;passphrasemagazine.com&#x2F;&quot;&gt;Passphrase Magazine&lt;&#x2F;a&gt; and asked to contribute an article. I accepted, of course, and was given a March 1st deadline. With the dealine looming, I wrote a 1500 word introductory article with two simple diagrams explaining ecash and ehash.&lt;&#x2F;p&gt;
&lt;p&gt;As a general productivity strategy, whenever possible, I like to double dip and accomplish two goals at the same time. So I finished the final display issues with my website and added the passphrase article as the first explanatory article on the landing page. It should be a great place for me to send people who want to learn more.&lt;&#x2F;p&gt;
&lt;p&gt;In time, I can add more articles to explain the concepts in more detail. I can also add documentation, user guides, and whatever else comes up over time. The website is almost ready to launch. I can run it locally and it looks great. I just need to hook up some DNS records and set up github pages to start serving them. It will be a big upgrade for the project to finally have a landing page on the internet.&lt;&#x2F;p&gt;
</content>
        
    </entry>
    <entry xml:lang="en">
        <title>PaperMod, Proof Sets, and Podcasts, Oh My!</title>
        <published>2025-01-27T00:00:00+00:00</published>
        <updated>2025-01-27T00:00:00+00:00</updated>
        
        <author>
          <name>
            
              vnprc
            
          </name>
        </author>
        
        <link rel="alternate" type="text/html" href="https://hashpool.dev/dev-logs/dev-log-2025-01-27/"/>
        <id>https://hashpool.dev/dev-logs/dev-log-2025-01-27/</id>
        
        <content type="html" xml:base="https://hashpool.dev/dev-logs/dev-log-2025-01-27/">&lt;h2 id=&quot;website&quot;&gt;Website&lt;&#x2F;h2&gt;
&lt;p&gt;I&#x27;ve made a lot of progress on hashpool in the last month. Over the holidays I worked on a website repository. I have a little experience hosting a website thanks to my BitDevs chapter but I knew I needed a more modern framework. My BitDevs site uses jekyll, which is not well supported anymore. I knew a lot of other BitDevs chapters were upgrading to Zola from the original jekyll repo so I went looking for a nice Zola theme to start with.&lt;&#x2F;p&gt;
&lt;p&gt;I found a cool looking theme called PaperMod and got to work importing all my dev logs there. This was a relatively easy task which was great for continuing my green box streak while keeping my work load low during the holidays.&lt;&#x2F;p&gt;
&lt;p&gt;Once I finished with the dev logs I turned my attention to molding the site layout to my needs. This was a much more difficult proposition given my unfamiliarity with the tools and concepts of web design. But I powered through my skill issues to get it in reasonable shape. I even managed to fix a display bug and upstream it. Nice!&lt;&#x2F;p&gt;
&lt;p&gt;You can see the site by cloning the &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;vnprc&#x2F;hashpool-website&quot;&gt;repo&lt;&#x2F;a&gt; and running it locally with &lt;code&gt;zola serve&lt;&#x2F;code&gt;. I have not published the site yet. I want to write some educational materials that will form a sort of landing page and clean up this part of the site layout so it looks good. I ran out of holiday time before I got that far. In the new year the kids returned to school and I had much more bandwidth to tackle harder coding problems so I turned my attention back to the Hashpool repo.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;full-proof-sets&quot;&gt;Full Proof Sets&lt;&#x2F;h2&gt;
&lt;p&gt;My big Hashpool accomplishment this month was rewriting the network transport layer to carry an array of 64 pieces of data instead of one. This enables hashpool to generate a full proof set for each submitted share. Now each time a miner submits a mining share, they receive ehash tokens adding up to exactly the difficulty of the submitted share. With this capability, I think it&#x27;s fair to say that ehash issuance has upgraded from a proof of concept to a featureful implementation.&lt;&#x2F;p&gt;
&lt;p&gt;In the process of building out this infrastructure I introduced the concepts of domain and wire types. A domain type represents the piece of data that you are working with, in this case signing keys, blinded secrets, and blinded signatures. A wire type is the encoded version of the domain type suitable for network transmission. My wire types carry the entire array of domain items.&lt;&#x2F;p&gt;
&lt;p&gt;I already had Sv2 structs that can each store a public key and some metadata fields in a way that the SRI encoding library is willing to encode. In order to transmit a full keyset I needed to store 64 keys, one for each power of 2 denomination that can fit into a 64 bit value. Essentially, to represent every possible denomination you need one key pair for each bit position. It&#x27;s very unlikely that anyone will ever mine a share with 63 leading zero bits but it&#x27;s technically possible and for a detail-oriented completionist like me it just feels right to build it this way.&lt;&#x2F;p&gt;
&lt;p&gt;Since SRI encodings are fixed length you need to have enough space to transmit an array of 64 pubkeys. Pubkeys are 33 bytes so that works out to 2112 bytes for the whole data structure, give or take a few header bytes. Unfortunately, the standard byte array types are not very granular, they jump from 255 bytes to 64,000 bytes. Oof! I have to use a 64kb data structure to store just over 2kb of data.&lt;&#x2F;p&gt;
&lt;p&gt;It would probably be a simple optimization to add a more fitting byte array type and stop wasting 62kb of space in each message but it&#x27;s not a priority at this stage of development. This might be a good task to tackle when converting my fork of SRI into an extension.&lt;&#x2F;p&gt;
&lt;p&gt;I used the index of the array to represent the amount of the tokens that key is used to sign. So the signing key in the first array element is used to sign tokens of amount 1, and the second array index corresponds to amount 2, then 4, then 8, and so on. The same applies to the arrays of blinded messages and blind signatures.&lt;&#x2F;p&gt;
&lt;p&gt;I took the strategy of implementing the domain and wire types three distinct times for the three domain types. Then I upgraded the network messages to use these wire array types and put in shim functions to convert an array to a single item (or vice versa) by discarding all but the lowest index entry. Kind of like adding new lanes to the highway that are closed while still under construction.&lt;&#x2F;p&gt;
&lt;p&gt;With this infrastructure in place, I deleted the shim functions one at a time and implemented the necessary functionality to hook up the wire array types to each other. First I deleted the function that discarded signing keys and updated the proxy service to import all the signing keys into the cashu wallet struct. Then I used those keys to generate blinded messages when a share is found. Next I deleted the helper function that discards blinded messages and updated my cdk code to sign all non-zero blinded messages in the array and return a wire array of blind signatures. Lastly, I deleted the final two helper functions (I was surprised to find that one of my helper functions wasn&#x27;t even used. Hah!) and imported all the signatures into the wallet to create a set of proofs totalling up to the work value of the mining share.&lt;&#x2F;p&gt;
&lt;p&gt;With this change, I could finally log out the complete proof set and verify that the tokens summed up to the work value of the share. A month of work finally realized! w00t! \o&#x2F;&lt;&#x2F;p&gt;
&lt;p&gt;Here is the commit message:&lt;&#x2F;p&gt;
&lt;pre style=&quot;background-color:#2b303b;color:#c0c5ce;&quot;&gt;&lt;code&gt;&lt;span&gt;ACHIEVEMENT UNLOCKED: mint full ehash proof sets
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;- pass the full premint secret collection to cdk for signing
&lt;&#x2F;span&gt;&lt;span&gt;- improve logging
&lt;&#x2F;span&gt;&lt;span&gt;- delete remaining functions that discard all but one proof
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;h2 id=&quot;refactoring&quot;&gt;Refactoring&lt;&#x2F;h2&gt;
&lt;p&gt;In the week since then I have been working hard to collapse the three redundant implementations into a common interface. I ran into a very frustrating snag with the Encodable and Decodable derive macros...again. I had a hell of a time deriving these traits on my structs the first time around. I expected to be able to just copy the existing structs and avoid additional trouble with these macros. Oh how naive I was...&lt;&#x2F;p&gt;
&lt;p&gt;It turns out that if you name a field in your struct &lt;code&gt;data&lt;&#x2F;code&gt; and try to derive Decodable (which is confusingly remapped to match the name of the &lt;code&gt;serde&lt;&#x2F;code&gt; version of that trait, Deserialize, even when you aren&#x27;t using &lt;code&gt;serde&lt;&#x2F;code&gt;...idk why! ¬Ø\_(„ÉÑ)_&#x2F;¬Ø) you get mysterious compile errors. The same mysterious compile errors you get when just about anything goes wrong with these derive traits.&lt;&#x2F;p&gt;
&lt;p&gt;I plan to rebase my fork against the latest SRI release and then open an issue with this feedback. I definitely want to leverage my experience to smooth the way for future SRI developers.&lt;&#x2F;p&gt;
&lt;p&gt;It took me a few days to work out this solution but just today I was finally able to combine the blinded secret and blind signature types under the new &lt;code&gt;DomainItem&lt;&#x2F;code&gt;&#x2F;&lt;code&gt;WireArray&lt;&#x2F;code&gt; generic implementations. My last commit added 84 lines of code and removed 370. Damn it feels good to be a gangster.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;next-steps&quot;&gt;Next Steps&lt;&#x2F;h2&gt;
&lt;p&gt;This probably represents two thirds of the code to be deleted. I think I can also collapse the default impls for BlindedMessage and BlindSignature. I still need to unify the signing keys under the same wire and domain generic structs but I&#x27;ll need to refactor the amount value out of Sv2SigningKey first.&lt;&#x2F;p&gt;
&lt;p&gt;Once this refactoring is completed to my satisfaction I need to clean up my cdk fork by rebasing it against latest master and getting ready to open a PR with my new functions. Again, I want to leverage my work to pave the way for future devs. My PR will add the BYO-network-transport use case to the cdk library. I can&#x27;t wait to see what other stuff people build with this functionality.&lt;&#x2F;p&gt;
&lt;p&gt;My next big Hashpool development goal will be to stand up a HTTP mint service and wallet CLI. I want to be able to stack ehash tokens in my cashu wallet as I find mining shares in real time. I think I will get people really excited once they can see ehash tokens land in their wallet. I might even use my hashpool.dev domain to stand up a testnet instance. Eventually, I could even run a mainnet instance that lets people donate hashrate to the development fund. In return, they get worthless ehash tokens that can&#x27;t be redeemed. I bet some folks would make that trade to support my work.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;delving-bitcoin-and-the-optech-podcast&quot;&gt;Delving Bitcoin and the Optech Podcast&lt;&#x2F;h2&gt;
&lt;p&gt;Last week I contributed my first post on Delving Bitcoin. I discovered in the Optech Year in Review issue a discussion of representing mining shares as ecash tokens from May. I had seen the original post on the topic when Gary shared it with me at the time but I hadn&#x27;t seen the discussion that followed. I didn&#x27;t have a ton of answers back in May but by now I had plenty of new research to share, which is exactly what I did. You can read it &lt;a href=&quot;https:&#x2F;&#x2F;delvingbitcoin.org&#x2F;t&#x2F;ecash-tides-using-cashu-and-stratum-v2&#x2F;870&#x2F;32&quot;&gt;here&lt;&#x2F;a&gt;.&lt;&#x2F;p&gt;
&lt;p&gt;The following week the Optech team asked me to join them on their podcast. Hell yeah! I was stoked! I think it went really well. You can listen &lt;a href=&quot;https:&#x2F;&#x2F;bitcoinops.org&#x2F;en&#x2F;podcast&#x2F;2025&#x2F;01&#x2F;21&#x2F;&quot;&gt;here&lt;&#x2F;a&gt;.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;nems-and-other-travel&quot;&gt;NEMS and other travel&lt;&#x2F;h2&gt;
&lt;p&gt;I&#x27;m travelling for the next two weeks, so I don&#x27;t know how much deep dev work I&#x27;ll get done. This week I am attending NEMS, the Nashville Energy and Mining Summit, to meet with mining industry folks and shill my project. I am most excited about the BitDevs before the conference. BitDevs is my jam and they seemed very interested when I offered to talk about my project.&lt;&#x2F;p&gt;
&lt;p&gt;The following week I&#x27;ll be travelling on personal business, so I&#x27;ll be looking for easy contributions to score a green check on those days. Now that I think about it, I need to update the screenshot on the README page...ü§î&lt;&#x2F;p&gt;
</content>
        
    </entry>
    <entry xml:lang="en">
        <title>Tis the Season for Wallet Cleanup</title>
        <published>2024-12-24T00:00:00+00:00</published>
        <updated>2024-12-24T00:00:00+00:00</updated>
        
        <author>
          <name>
            
              vnprc
            
          </name>
        </author>
        
        <link rel="alternate" type="text/html" href="https://hashpool.dev/dev-logs/dev-log-2024-12-24/"/>
        <id>https://hashpool.dev/dev-logs/dev-log-2024-12-24/</id>
        
        <content type="html" xml:base="https://hashpool.dev/dev-logs/dev-log-2024-12-24/">&lt;p&gt;I have spent the past few weeks cleaning up the hashpool codebase. In the process of sprinting towards ecash proofs I basically extracted only the pieces I needed into the SRI codebase. This is a messy arrangement. I hate working in a messy environment, it puts a drag on everything you try to build. Before I start working toward redemptions I want to clean up issuance as much as possible. This means putting the pieces back into the cashu wallet in a way that makes sense for my usecase. When I have the wallet working the way I want I will open a PR to cdk. I&#x27;m still a ways off, though.&lt;&#x2F;p&gt;
&lt;p&gt;I added wallet functions to perform a bunch of tasks without making any network calls. This included:&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;add and retrieve keysets&lt;&#x2F;li&gt;
&lt;li&gt;generate blinded secrets
&lt;ul&gt;
&lt;li&gt;keep count of generated tokens&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;store blinded secrets in the wallet
&lt;ul&gt;
&lt;li&gt;db support not yet implemented&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;generate proofs
&lt;ul&gt;
&lt;li&gt;combine blinded secrets with blinded sigs&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;p&gt;I also deleted a bunch of code:&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;logic I moved into the cashu wallet&lt;&#x2F;li&gt;
&lt;li&gt;shared state between SRI components&lt;&#x2F;li&gt;
&lt;li&gt;unnecessary fields, functions, Options, Mutexes, lifetimes&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;p&gt;God I love deleting code!&lt;&#x2F;p&gt;
&lt;p&gt;There are a couple of things I need to keep in mind to reevaluate or fix later.&lt;&#x2F;p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;I can&#x27;t assume that the active keyset used to generate a blinded secret will still be active when I go to combine the secret and signature to make a proof. I&#x27;m not sure yet whether I can still generate that ecash token or if it will be lost, but this decision will inform how to handle this edge case.&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;I also reinterpreted the cashu protocol a bit. I am using the mining share header hash output as the quote identifier.&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;&#x2F;ol&gt;
&lt;p&gt;Usually a BOLT11 invoice would go here. I think the hash header is the most direct translation to a LN invoice for my use case. Instead of providing an LN invoice and validating it with a proof of payment, the pool validates the miner&#x27;s proof of work by checking the block template they are mining on and the difficulty of the block header hash. I think this is a very straight-forward translation of the concept but I should spend some more time teasing out all of the implications of this architecture.&lt;&#x2F;p&gt;
&lt;p&gt;It took a bit of plumbing in SRI to get the block header hash from the share validation code to the success message. I&#x27;m not sure if it is more appropriate to calculate this value once and pass it around within the codebase or to regenerate it at the point where it&#x27;s needed. I don&#x27;t think it&#x27;s a question I need to answer any time soon. We can optimize this later. For now, I think passing around the block header hash makes a ton of sense to human developers so I&#x27;m happy with this construction.&lt;&#x2F;p&gt;
&lt;p&gt;I have a little voice in the back of my mind that tells me I don&#x27;t need to worry too much about efficiency of implementation because the end user will have the pool difficulty setting as a knob to turn that will solve all performance problems, at the cost of increased payout variability for miners. For pleb miners and decentralization of block template production, I think this is a great tradeoff. In terms of attracting developer attention I think making the design more understandable to meatbags with spongy human brains like myself is also a great tradeoff.&lt;&#x2F;p&gt;
&lt;p&gt;I am pretty close to capturing all of the wallet state in cdk but I am still generating one token per share with amount 1. I wrote a function to calculate the amount of ehash to issue for each share. I call this function and log the &#x27;work&#x27; value along with the block header hash.&lt;&#x2F;p&gt;
&lt;p&gt;I tried to pass this value to cdk during token minting but despite initializing the mint with one key in the keyset, it still tries to mint a bunch of tokens. Before I can mint this amount of ehash I need to revisit the single keyset key workaround. I ran into trouble with SRI encodings in the past but I think the solution is to simply calculate the maximum number of keys needed to represent every possible difficulty and create a (largeish) fixed length struct to store those keys. This is my next development goal for after the holidays.&lt;&#x2F;p&gt;
&lt;p&gt;We&#x27;re planning a trip after Christmas to a snowy place for the kids to enjoy. I want to minimize my workload during this time without missing a day so I&#x27;ll probably start standing up the hashpool.dev website repo, unless I can find something even easier. =)&lt;&#x2F;p&gt;
&lt;p&gt;I haven&#x27;t started work on the mpsc design but I have a great code tour from Gary that follows the existing design through the SRI codebase. This will result in a cleaner design. I need to grow my understanding of the mpsc architecture in order to prioritize this work.&lt;&#x2F;p&gt;
&lt;p&gt;Merry Christmas, y&#x27;all. We are winning. Can&#x27;t stop now!&lt;&#x2F;p&gt;
</content>
        
    </entry>
    <entry xml:lang="en">
        <title>The Proofs Are in the Pudding</title>
        <published>2024-12-08T00:00:00+00:00</published>
        <updated>2024-12-08T00:00:00+00:00</updated>
        
        <author>
          <name>
            
              vnprc
            
          </name>
        </author>
        
        <link rel="alternate" type="text/html" href="https://hashpool.dev/dev-logs/dev-log-2024-12-08/"/>
        <id>https://hashpool.dev/dev-logs/dev-log-2024-12-08/</id>
        
        <content type="html" xml:base="https://hashpool.dev/dev-logs/dev-log-2024-12-08/">&lt;p&gt;I hit my first milestone this week. I have successfully generated proofs in the translator proxy. To phrase it summarily: I can now generate ecash tokens in exchange for proof of work mining shares. LET&#x27;S GO BABY! \o&#x2F;&lt;&#x2F;p&gt;
&lt;p&gt;I took a screenshot and &lt;a href=&quot;https:&#x2F;&#x2F;njump.me&#x2F;nevent1qvzqqqqqqypzp5c99j3784frk8kgqec7kxa6q5t69afzux2h0rwg8hgr4rvy59cwqy2hwumn8ghj7erfw36x7tnsw43z7un9d3shjqpqfpzmnrmcr02ua3kpsvy93l95cfgk7yuaj5zmvadjtd7n4ehcegls0528lx&quot;&gt;posted it to nostr&lt;&#x2F;a&gt;. Calle went nuts resharing on nostr and twitter, driving a lot of attention to my project.&lt;&#x2F;p&gt;
&lt;p&gt;&lt;img src=&quot;&#x2F;images&#x2F;dev-logs&#x2F;excellent.jpg&quot; alt=&quot;excellent&quot; &#x2F;&gt;&lt;&#x2F;p&gt;
&lt;p&gt;I spent a lot of time trying to get variable length encoding working in order to send an entire keyset through SRI message transport. After trying a bunch of things without success I listened to reason (read: I listened to Gary) and pared the Sv2Keyset struct down to a single key. Once I removed the complexity of variable length data types it was fairly simple to get encoding to work using the existing encoding traits. I still need to revisit this but it doesn&#x27;t need to stand in the way of constructing proofs.&lt;&#x2F;p&gt;
&lt;p&gt;With this core functionality working it was a small step to combine the blinded secret and blinded signature into a proof in the translator proxy. Right now I just log out the proof and store all the constituent pieces in various fields all over the codebase. My next development goal is to clean this up and encapsulate it into the cdk wallet where it belongs.&lt;&#x2F;p&gt;
&lt;p&gt;I also began to consolidate cashu specific logic into a new cashu.rs module in the mining protocol crate. This keeps the codebase more organized and will help when I eventually upgrade my project from an SRI fork to an SRI extension. Included in this crate is my first unit test to encode and decode the keyset struct.&lt;&#x2F;p&gt;
&lt;p&gt;I have begun work to encapsulate the proxy cashu logic into the wallet. I created two quick and dirty functions to add the keyset to the wallet db and retrieve it but I obviously missed something because retrieval always returns an empty list. Just today I added a unit test to my cdk fork to reproduce this behavior. Commits to this fork don&#x27;t count on my github profile because it is a fork of another repo. This is dumb because it&#x27;s a necessary step in the development process. It just goes to highlight how imperfect the green boxes are as a metric. As a result, I find myself working harder than intended on a Saturday afternoon just to get that green box. I need to come up with a strategy to improve this situation, else work on my cdk fork will get deprioritized. The dumbest thing would be to break it out from being an official fork just like I did for the hashpool repo. Frankly this is stupid, it doesn&#x27;t need to be a top level repo. I could do other dumb things like opening PRs to myself. Need to evaluate possible solutions and pick the least stupid option.&lt;&#x2F;p&gt;
&lt;p&gt;The impact that my green box crusade has had on my development practices has not escaped me. I will probably turn my experience into a blog post at some point highlighting how Github&#x27;s little developer productivity measuring widget changes development practices for better and for worse. It should make for interesting reading for those who use this metric and for those developers like myself who are evaluated based on it. Hopefully I can drive some positive change in the ecosystem with this work.&lt;&#x2F;p&gt;
&lt;p&gt;I received notice from OpenSats that my application was rejected on the same day that I shared my first milestone success. They provided zero actionable feedback in their rejection email, citing only &quot;a very competitive applicant pool&quot; for my rejection. I reached out through other channels and learned that given my ask amount they want to see a more firm budget and timeline, and a proof of concept. My contact suggested I keep working hard and apply again next month. Great! Will do! Not sure why they couldn&#x27;t just put that stuff in the email. Surely, the quality of an applicant&#x27;s personal network should not be a blocking factor in the grant process&lt;sup class=&quot;footnote-reference&quot;&gt;&lt;a href=&quot;#*&quot;&gt;1&lt;&#x2F;a&gt;&lt;&#x2F;sup&gt;.&lt;&#x2F;p&gt;
&lt;p&gt;Looking forward, I need to line up some relatively easy tasks to knock out day by day during the upcoming holiday season. The geen boxes must flow. I think setting up a website would be a good candidate here. I need to do it anyway and it&#x27;s relatively easy to make daily tweaks while on holiday without seriously disrupting our vacation plans. I just bought the hashpool.dev domain name in preparation for this work.&lt;&#x2F;p&gt;
&lt;div class=&quot;footnote-definition&quot; id=&quot;*&quot;&gt;&lt;sup class=&quot;footnote-definition-label&quot;&gt;1&lt;&#x2F;sup&gt;
&lt;p&gt;In retrospect, this is a terrible argument. FOSS developers starting new projects need to attract devs and users and this is largely a factor of their networking skills. I&#x27;m not happy with the negative tone of this dev log but I will leave it as a historical artifact. Setbacks are to be expected. My friend J has a great spin on this: don&#x27;t think of rejection as a step backward, instead count each one as a notch in your belt, a move forward towards your ultimate goal. I like this framing because nothing charges me up more than making progress toward my goal.&lt;&#x2F;p&gt;
&lt;&#x2F;div&gt;
</content>
        
    </entry>
    <entry xml:lang="en">
        <title>CDK Branch Maintenance, Keyset Encoding, and More Grants</title>
        <published>2024-11-24T00:00:00+00:00</published>
        <updated>2024-11-24T00:00:00+00:00</updated>
        
        <author>
          <name>
            
              vnprc
            
          </name>
        </author>
        
        <link rel="alternate" type="text/html" href="https://hashpool.dev/dev-logs/dev-log-2024-11-24/"/>
        <id>https://hashpool.dev/dev-logs/dev-log-2024-11-24/</id>
        
        <content type="html" xml:base="https://hashpool.dev/dev-logs/dev-log-2024-11-24/">&lt;p&gt;For the past 10 days I have focused on mainly three areas:&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;updating my cdk branch&lt;&#x2F;li&gt;
&lt;li&gt;continuing work on ecash issuance&lt;&#x2F;li&gt;
&lt;li&gt;applying for grants&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;p&gt;Up until now I have been building on a branch of cdk that I have not been maintaining. I added a few functions and trait derivations but I haven&#x27;t focused on upstreaming those changes or keeping the branch up to date with cdk main. I was focused on gaining forward momentum in hashpool. This was a good tradeoff, but I feel I have achieved some momentum and settled back in to my routine after all the October travel so the time has come to update my dependencies.&lt;&#x2F;p&gt;
&lt;p&gt;I started by opening a &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;cashubtc&#x2F;cdk&#x2F;pull&#x2F;452&quot;&gt;PR&lt;&#x2F;a&gt; with some new functions to convert the Id struct to a u64 and back. Turns out this is not a very rusty pattern. I learned that implementing the From trait is the better way to go about this and that cdk already had a From impl to convert Id to a u64. But no function to convert it back? It turns out this was actually implemented to support NUT13 deterministic secrets. And it was kind of buggy. It actually implemented a one way function to create a &#x27;fingerprint&#x27; that fits inside a u32 but returned it as a u64.&lt;&#x2F;p&gt;
&lt;p&gt;I opened a PR to cdk to return a u32 fingerprint instead and also implement the From traits to convert &lt;code&gt;Id&lt;&#x2F;code&gt; to and from a u64. Thesimplekid shot down the u64 From traits in PR review but he did merge my fix for the existing From trait. It feels good to get my PR merged! With the knowledge that cdk won&#x27;t support these traits I built the solution I needed in hashpool and learned about the newtype pattern in the process. I also applied my newfound knowledge of the From trait to rewrite the &lt;code&gt;Sv2BlindedMessage&lt;&#x2F;code&gt; conversion functions.&lt;&#x2F;p&gt;
&lt;p&gt;I removed a bunch of &lt;code&gt;#[derive(Debug)]&lt;&#x2F;code&gt; statements and implemented the debug trait manually on the &lt;code&gt;Downstream&lt;&#x2F;code&gt; and &lt;code&gt;PoolSv2&lt;&#x2F;code&gt; structs. This way I can just skip debug logging the cdk components that don&#x27;t support it. This removed the need for even more of the code changes I had made to cdk.&lt;&#x2F;p&gt;
&lt;p&gt;I created a new branch off the latest main and reapplied the one remaining change I needed, &lt;code&gt;generate_premint_secrets&lt;&#x2F;code&gt;. This change is necessary and also not ready to open a PR. I would like to wait until I have working code that can construct a proof before proposing this change upstream because I will need another related function and will probably want to make additional changes to &lt;code&gt;generate_premint_secrets&lt;&#x2F;code&gt;.&lt;&#x2F;p&gt;
&lt;p&gt;But on the new &quot;hashpool&quot; branch of cdk there was a new problem. On my previous branch I had manually added the &lt;code&gt;HASH&lt;&#x2F;code&gt; currency type. But hard coding currency types was always an unmaintainable solution and cdk had changed since I last branched. I needed to use the new &lt;code&gt;CurrencyType::Custom&lt;&#x2F;code&gt; enum, but when I did this my mint would immediately panic on startup. It was trying to create derivation paths for deterministic secrets but there were none defined for the &lt;code&gt;Custom&lt;&#x2F;code&gt; enum. I fixed this issue on my cdk branch and opened a &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;cashubtc&#x2F;cdk&#x2F;pull&#x2F;464&quot;&gt;PR&lt;&#x2F;a&gt; to push this fix upstream. Turns out my planned fix would break the spec. In my PR I got some guidance on how to provide the derivation paths in the &lt;code&gt;Mint::new&lt;&#x2F;code&gt; constructor. I had glossed over those changes in my haste to get the code to compile.&lt;&#x2F;p&gt;
&lt;p&gt;I considered generating deterministic derivation path indexes from the currency string but dismissed it as too complex at the time. This would simplify the requirements to start up a mint so I think it might be worthwhile to build. To my surprise Thesimplekid was receptive to this idea in my PR so I would like to try to implement it. I&#x27;d also like to salvage some of the many unit tests I wrote for that PR. But I put that effort on the back burner for now in order to focus on my primary development goal: hashpool. I set the PR to draft, hopefully I can get back to this work soon.&lt;&#x2F;p&gt;
&lt;p&gt;With hashpool pointing to a much cleaner and more recent branch of cdk I could proceed working on ehash issuance. With a few more days of work I had built all the plumbing necessary for the pool to sign the blinded message and return it to the proxy where I attempted to reunite them into a Proof, another term for an ecash token. So close!&lt;&#x2F;p&gt;
&lt;p&gt;Creating the proof is still broken. It turns out I need to store more than just the keyset_id, I need to retrieve the whole keyset when the proxy first connects to the mint. Yesterday I implemented the &lt;code&gt;Sv2KeySet&lt;&#x2F;code&gt; and &lt;code&gt;Sv2SigningKey&lt;&#x2F;code&gt; structs to represent this data. I plan to get the keyset working and finish generating proofs. Then I want to push as much of this state as possible into the wallet to handle for me. Once I have this working I will be ready to finalize my &lt;code&gt;generate_premint_secrets&lt;&#x2F;code&gt; PR. It will include another, to be written, function that encapsulates the second half of the &lt;code&gt;wallet::mint&lt;&#x2F;code&gt; function after the network call to the mint.&lt;&#x2F;p&gt;
&lt;p&gt;I am quickly gaining momentum and facility with these codebases. It feels good to be closing in on my first milesone: ecash issuance. ü§ô&lt;&#x2F;p&gt;
&lt;p&gt;I also applied for Spiral and OpenSats grants. As part of this process I converted my dev logs and project description gist to markup files and cleaned them up to be more readable directly from github. I think it would also be worthwhile to add some diagrams. This could be a stepping stone to a project website down the road. I also heard back from HRF that I had passed the first round of the application process. Noice!&lt;&#x2F;p&gt;
</content>
        
    </entry>
    <entry xml:lang="en">
        <title>TABconf, Encodings, and Grants</title>
        <published>2024-11-14T00:00:00+00:00</published>
        <updated>2024-11-14T00:00:00+00:00</updated>
        
        <author>
          <name>
            
              vnprc
            
          </name>
        </author>
        
        <link rel="alternate" type="text/html" href="https://hashpool.dev/dev-logs/dev-log-2024-11-14/"/>
        <id>https://hashpool.dev/dev-logs/dev-log-2024-11-14/</id>
        
        <content type="html" xml:base="https://hashpool.dev/dev-logs/dev-log-2024-11-14/">&lt;p&gt;TABconf was great! I spent the two workshop days hacking on hashpool with Gary. We don&#x27;t get to meet in person much, even though we live relatively close. We didn&#x27;t produce a code branch that compiles but Gary&#x27;s knowledge of Sv2 was very useful in navigating the codebase and understanding the flaws of my previous design. When I returned home and continued work I was able to reference the two branches we created at TAB to push forward. I was previously trying to send the keyset_id downstream to the proxy on the SetupConnection message, but this is a common message that is shared between many Sv2 roles which explains my issues with the job declarator. A better design is to include the keyset_id on the extended channel success message which does not involve the job declarator.&lt;&#x2F;p&gt;
&lt;p&gt;I gave my talk at 9am on the last day of the conference. Honestly, I was not feeling 100% so it was kind of low energy. I feel like I did a better job at btc++ so I&#x27;m glad it&#x27;s the one with a recording. After this I hosted the Lightning Socratic Seminar and sat on a Mining Socratic Panel which I feel went really well. All of my events were in the socratic village which doesn&#x27;t allow recordings.&lt;&#x2F;p&gt;
&lt;p&gt;In the two weeks since then I have successully implemented passing the keyset_id downstream from the pool to the proxy. The proxy now uses the keyset_id to generate blinded secrets. Passing the blinded secret around is more complicated than the keyset_id. keyset_id can be represented as a u64, which is a primitive type. The blinded secret is composed of multiple types, including a cryptgraphic key. I implemented a Sv2BlindedMessage struct using Sv2&#x27;s custom data types to enable it to be serialized and sent back upstream. I had a hell of a time getting it to derive the Serialize and Deserialize trait for this struct. I think I was just pushing myself too hard under false time constraints. After a night of rest I was able to find out the problem. I needed to import Decodable and Encodable from both the binary_codec_sv2 and the derive_codec_sv2 crates. These traits are aliased to Serialize and Deserialize everywhere in the codebase. This confusing arrangement threw me for a loop. I should find out why it&#x27;s written this way.&lt;&#x2F;p&gt;
&lt;p&gt;Another stumbling block I ran into was converting the 33 byte cdk pubkey (actually a secp256k1::PublicKey) into a 32 byte Sv2 PubKey. I just dropped the first byte that encodes the parity of the y coordinate on the elliptic curve and left a TODO comment to resolve later. Now that I think about it, I should probably just add a parity byte to the struct. I will work on this tomorrow.&lt;&#x2F;p&gt;
&lt;p&gt;Aside from dev work I also submitted a grant application to HRF. I went a little crazy and wrote 2500 words to describe my project. The web form asked for a detailed description! When I tried to paste my answer in I realized they only give you 2000 characters. Oops. I threw up a secret &lt;a href=&quot;https:&#x2F;&#x2F;gist.github.com&#x2F;vnprc&#x2F;a50ecfaf6a55cb3bf52d6ee62d55876a&quot;&gt;gist&lt;&#x2F;a&gt; and linked to it in my application. Just like the talk I gave, this was a good exercise in clarifying my thinking. I can probably reuse this text elsewhere in the future.&lt;&#x2F;p&gt;
&lt;p&gt;I need to apply to Spiral and OpenSats also. Part of the reason I haven&#x27;t done this yet is that I set a goal to do at least a little dev work every day. And I mean every day. Today marks 13 consecutive days with a github contribution. I&#x27;m going to keep the streak going as long as I can; I&#x27;m calling it Operation Greenwash. My buddy Johnny pointed out that I need to pay attention to my github profile since grant committees will be looking at it. The green squares in github are far from a perfect metric but if it&#x27;s the metric I have to game to get a grant then that&#x27;s just what I will do.&lt;&#x2F;p&gt;
&lt;p&gt;After my experience with Serialize and Deserialize last weekend I realize I need to get better at stopping work and committing what I have rather than thrashing in pursuit of a minor goal. This is an unhealthy approach that will eventually lead to burnout. It&#x27;s a marathon, not a sprint. I should also get better at queueing up small tasks to knock out on the weekend. I think that contributing to hashpool and&#x2F;or cdk daily will help me more quickly climb the skill curve and enable me to tackle bigger tasks, which will surely be needed to get this thing across the finish line.&lt;&#x2F;p&gt;
</content>
        
    </entry>
    <entry xml:lang="en">
        <title>btc++ and Nix</title>
        <published>2024-10-22T00:00:00+00:00</published>
        <updated>2024-10-22T00:00:00+00:00</updated>
        
        <author>
          <name>
            
              vnprc
            
          </name>
        </author>
        
        <link rel="alternate" type="text/html" href="https://hashpool.dev/dev-logs/dev-log-2024-10-22/"/>
        <id>https://hashpool.dev/dev-logs/dev-log-2024-10-22/</id>
        
        <content type="html" xml:base="https://hashpool.dev/dev-logs/dev-log-2024-10-22/">&lt;p&gt;I have not been making regular dev log updates due to personal and business travel, but I have not been idle. As Average Gary let me know, it&#x27;s time to get back up on the horse. Side note: shout out to Gary! You are like a boxing coach who keeps me going when my internal drive starts to flag. Thank you, brother. &amp;lt;3&lt;&#x2F;p&gt;
&lt;p&gt;In the process of creating the presentation I delivered at btc++ I have uncovered significant gaps in my thinking. The biggest of these is my naive conception of PPLNS payouts. I was originally picturing what I now know is called proportional mining, where all shares are paid once each time a block is found. This is a bad idea for public pools because it leads to a behavior called pool hopping, which dramatically increases pool hashrate variability. It&#x27;s actually not terrible if you have a whitelist of miners. I may use this payout method for the passthrough construction if it makes sense to do so but I suspect that once I code up the payout calculations it will be simpler and easier not to reimplement payouts.&lt;&#x2F;p&gt;
&lt;p&gt;There is a lack of quality educational material about pool payouts but I managed to find two good sources: a &lt;a href=&quot;https:&#x2F;&#x2F;bitcointalk.org&#x2F;index.php?topic=39832&quot;&gt;2011 bitcointalk thread&lt;&#x2F;a&gt; and a &lt;a href=&quot;https:&#x2F;&#x2F;mintpond.com&#x2F;b&#x2F;prop-vs-pplns-vs-pps-mining-pool-reward-systems&quot;&gt;MintPond blog post&lt;&#x2F;a&gt; (MintPond is apparently a zcoin mining pool). The second reply on bitcointalk basically describes the use case of ehash at a high level. This is great confirmation that I&#x27;m on the right track! All the best ideas have already been discussed 10 years ago on bitcointalk. :)&lt;&#x2F;p&gt;
&lt;p&gt;With newfound understanding I rewrote the slide explaining how and why PPLNS works. I realized that I was barking up the wrong tree with an exponential decay function. I think that might work but it&#x27;s actually much simpler to use a linear decay function. All we need to do is amortize share payouts to prevent pool hopping and a linear decay makes the math much simpler to understand. I have found that having simplicity as an engineering goal produces far better results in the long run, so let&#x27;s keep it simple until we identify a need to make it complex.&lt;&#x2F;p&gt;
&lt;p&gt;At BTC++ Berlin I spent the week explaining my idea and sharpening my thoughts on it. After the conference I also had some productive conversations on the stratum v2 discord server research channel that have driven further improvements in my understanding. I brought away two big realizations from these conversations:&lt;&#x2F;p&gt;
&lt;p&gt;First: existing pools combine the roles of pricing hashrate and producing block templates. This is the moral hazard that has lead to an unhealthy market. Hashpool separates out the role of pricing hashrate. I want to get to a place where I can separate out block template production, but that won&#x27;t be in the first version. At the end of the day pools should be dumb aggregators of hashrate that compete only in the quality of service they deliver, not via externalities to the core business like monopoly market positioning, deep capital accounts, or political connections.&lt;&#x2F;p&gt;
&lt;p&gt;My second realization, driven by the discussion with Matt Corallo on Discord, was that Hashpool is actually two different ideas. It combines the concept of a self-hosted adjunct mining pool with an ecash-powered free market for hashrate. You can build either concept in isolation but there are some synergies in combining them. Smaller pools should cater to smaller miners, so the adjunct mining pool concept really needs micropayments to make sense. You can build a mining pool with BOLT12 today, in fact Ocean and Braiins have already done this. Another micropayment solution is ecash payouts. I like this solution for its architectural simplicity, which I believe will allow for more innovation in the long run. For hashpool, you need a cashu server to implement ehash tokens. Since you are already running cashu to account for mining shares, it is a small leap to use it for payouts as well. This reduces the burden on wallets to support BOLT12 payouts and will drive far better UX due to the simplicity of the cashu spec. The other main benefit of building hashpool as an adjunct mining pool is that self-hosted Hashpools will be far more resilient to interference from the state. It&#x27;s much harder to play whack-a-mole than to take down one large centralized service provider. With robust ehash marketplaces it should be easy to buy and sell ehash from different Hashpools on the same exchange.&lt;&#x2F;p&gt;
&lt;p&gt;Also, Bob McElrath of Braidpool commented during the discord discussion that I may have solved one of the problems they are wrestling with. They were also closing in on the idea of adjunct mining pools. This is another important signal that I&#x27;m on the right track. Another team working on a different design with a different approach also determined that a layered mining pool model served their needs best.&lt;&#x2F;p&gt;
&lt;p&gt;At the BTC++ hackathon I hooked up with some awesome devs who helped me nixify my setup. This is a huge win for me personally since my previous setup was to open 6 tabs and manually run a process in each tab. Now I can spin up the whole thing with a single terminal command, and it has a sexy terminal UI to boot!&lt;&#x2F;p&gt;
&lt;p&gt;This week is TABconf. I hope it is at least as productive as btc++! I suspect it will be even more so.&lt;&#x2F;p&gt;
</content>
        
    </entry>
    <entry xml:lang="en">
        <title>Trial and Error</title>
        <published>2024-09-22T00:00:00+00:00</published>
        <updated>2024-09-22T00:00:00+00:00</updated>
        
        <author>
          <name>
            
              vnprc
            
          </name>
        </author>
        
        <link rel="alternate" type="text/html" href="https://hashpool.dev/dev-logs/dev-log-2024-09-22/"/>
        <id>https://hashpool.dev/dev-logs/dev-log-2024-09-22/</id>
        
        <content type="html" xml:base="https://hashpool.dev/dev-logs/dev-log-2024-09-22/">&lt;p&gt;This week I started making more involved changes to the stratum v2 repo to set up the necessary message passing infrastructure. Unsurprisingly, this is more time consuming than the work I have done in previous weeks. &lt;code&gt;keyset_id&lt;&#x2F;code&gt; message passing is not quite working yet so I did not complete any major milestones this week.&lt;&#x2F;p&gt;
&lt;p&gt;My strategy this far has been to generate blinded secrets at the appropriate place in the code using fake keyset data. In practice, the pool&#x2F;mint will need to generate the keyset and transmit the keyset_id to the proxy&#x2F;wallet before it can generate valid ecash tokens. I created two new message structs: SetupConnectionMint and SetupConnectionSuccessMint to carry this data.&lt;&#x2F;p&gt;
&lt;p&gt;I have my doubts as to whether this is the right approach but by pursuing this strategy I expect to learn a lot about the stratum v2 design and what this means in terms of engineering trade-offs. I would like to spend some more time understanding how stratum extensions are built but I think I can punt on this for now. The end result will most likely be an extension rather than a fork but in my engineering career I have found it very useful to consider the first implementation of any system as a practice round. When trying to do something new and hard you always end up rewriting it anyway, so by embracing epehemerality early on you can focus more on discovering the right requirements and abstractions for your needs rather than the ideal design.&lt;&#x2F;p&gt;
&lt;p&gt;I previously found that modifying the SetupConnection struct directly creates incompatibilities with bitcoind. Perhaps creating new messages can avoid this problem but it requires a lot of boilerplate code. In the process of building out the new message infrastructure I was surprised to find out that the jd client serves as a passthrough layer to establish a connection between the proxy and pool. I definitely should study the stratum protocol to better understand the topology of the various services.&lt;&#x2F;p&gt;
&lt;p&gt;I added keyset_id as a parameter of the JobDeclaratorClient, DownstreamMiningNode, and Upstream structs to store this state and pass it on when needed. This work on the upstream struct is still incomplete. For now, I have hard coded keyset ID to 0. I can see this in the logs so I know that the messages are working even if the value they are intended to carry isn&#x27;t being transmitted fully.&lt;&#x2F;p&gt;
&lt;p&gt;Once I can pass the pool-generated keyset ID to the proxy I will need to build infrastructure to transmit the blinded messages to the pool, the pool will need to sign each share and then transmit the signatures back to the proxy for storage.&lt;&#x2F;p&gt;
&lt;p&gt;I have some personal travel plans coming up so I will spend next week putting together a Hashpool presentation for btc++ Berlin. There is a nostr hackathon before the conference so I might take some time to look into a nostr project. I suspect that storing your ehash on a nostr relay will be a critical usability feature. Maybe I can get a head start by meeting up with some nostr hackers in Berlin. Another idea is a nostr-powered ehash exchange.&lt;&#x2F;p&gt;
&lt;p&gt;I wrote a mini brain dump with an eye towards auditor requirements in a &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;stratum-mining&#x2F;stratum&#x2F;discussions&#x2F;1052&quot;&gt;comment&lt;&#x2F;a&gt; on this Sv2 auditor role issue. This is a good preview of the talk I plan to give. I will convert it to a presentation format, add visuals, explain what problems it solves, and add future development ideas.&lt;&#x2F;p&gt;
</content>
        
    </entry>
    <entry xml:lang="en">
        <title>SRI Full Stack or: How I Learned to Stop Worrying and Love Testnet4</title>
        <published>2024-09-15T00:00:00+00:00</published>
        <updated>2024-09-15T00:00:00+00:00</updated>
        
        <author>
          <name>
            
              vnprc
            
          </name>
        </author>
        
        <link rel="alternate" type="text/html" href="https://hashpool.dev/dev-logs/dev-log-2024-09-15/"/>
        <id>https://hashpool.dev/dev-logs/dev-log-2024-09-15/</id>
        
        <content type="html" xml:base="https://hashpool.dev/dev-logs/dev-log-2024-09-15/">&lt;p&gt;I made good progress this week:&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;switched from the hosted template provider to running my own full stack
&lt;ul&gt;
&lt;li&gt;this required me to spin up a testnet4 bitcoin node&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;added a cashu mint to the pool role&lt;&#x2F;li&gt;
&lt;li&gt;added &lt;code&gt;keyset_id&lt;&#x2F;code&gt; field to the SetupConnectionSuccess struct
&lt;ul&gt;
&lt;li&gt;more importantly, I learned why this approach won&#x27;t work and what approach will&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;p&gt;In order to get off of the hosted template provider I simply followed the instructions in the &quot;Running all Roles&quot; section of the &lt;a href=&quot;https:&#x2F;&#x2F;stratumprotocol.org&#x2F;getting-started&#x2F;#ii-getting-started---running-all-roles&quot;&gt;guide&lt;&#x2F;a&gt;. The Stratum v2 documentation and project maturity has been super helpful. It would be very hard to get a project like this off the ground if I wasn&#x27;t able to stand on the shoulders of these giants.&lt;&#x2F;p&gt;
&lt;p&gt;I spun up a testnet4 node using Sjors&#x27; fork. It worked like a charm. Testnet4 is being added to the next major bitcoind release so I might want to switch over if I begin having issues with my node, but so far so good.&lt;&#x2F;p&gt;
&lt;p&gt;I added a cashu mint to the pool role using cdk. At this point it didn&#x27;t do anything but just getting it to compile and run was further than I got with moksha. No dependency issues, yay!&lt;&#x2F;p&gt;
&lt;p&gt;I took some time to explore the stratum codebase and cashu protocol more deeply and work out a plan for how to generate the keyset and pass it to the client side. I decided to add a keyset_id field to the SetupConnectionSuccess message struct. The keyset ID is the one piece of information the wallet needs to produce valid blinded signatures. Normally, a collection of keyset IDs is used by the wallet software to generate different denominations of ecash but a single one will do for my purposes. At this stage, I&#x27;m just showing what is possible and scouting the path ahead.&lt;&#x2F;p&gt;
&lt;p&gt;It took another day to understand the stratum plumbing enough to pass the message along from pool instantiation to the SetupConnectionSuccess message. Once I appeased all of the rust compiler&#x27;s demands I started it up to kick the tires and found a nice error:&lt;&#x2F;p&gt;
&lt;pre style=&quot;background-color:#2b303b;color:#c0c5ce;&quot;&gt;&lt;code&gt;&lt;span&gt;2024-09-13T02:59:39.897045Z INFO pool_sv2::lib::template_receiver: Connected to template distribution server at 127.0.0.1:8442 
&lt;&#x2F;span&gt;&lt;span&gt;2024-09-13T02:59:40.011559Z ERROR pool_sv2::lib: Could not connect to Template Provider: Roles Logic SV2 error: `BinarySv2Error(DecodableConversionError)` 2024-09-13T02:59:40.011581Z ERROR network_helpers_sv2::noise_connection_tokio: Disconnecting from client due to error receiving: receiving from an empty and closed channel - 127.0.0.1:8442
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Something in the stack didn&#x27;t appreciate that I had changed the message format! A little more digging revealed that bitcoind was listening on localhost:8442. I don&#x27;t need to modify any messages being sent to bitcoind, only messages between the pool and translator proxy. So my hacky code changes were applied more broadly than needed and this conflicted with what bitcoind was expecting.&lt;&#x2F;p&gt;
&lt;p&gt;Thankfully, @fi3 on the discord showed me the way: I need to write a Sv2 extension and define my own message type. Even better, @fi3 has already written one that I can use for a reference! \o&#x2F;&lt;&#x2F;p&gt;
&lt;p&gt;Next week goals:&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;refactor my branch into a Sv2 extension&lt;&#x2F;li&gt;
&lt;li&gt;define a new message type to be used when a translator proxy daemon connects to a pool daemon
&lt;ul&gt;
&lt;li&gt;include &lt;code&gt;keyset_id&lt;&#x2F;code&gt; field&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;in the translator proxy, retrieve the keyset_id from the pool and use it to produce blinded secrets&lt;&#x2F;li&gt;
&lt;li&gt;define a new share submission message type that includes the blinded secret&lt;&#x2F;li&gt;
&lt;li&gt;pool: sign the blinded message when a share submission is accepted&lt;&#x2F;li&gt;
&lt;li&gt;define a new share submission accepted message type that includes the blinded signature from the pool&lt;&#x2F;li&gt;
&lt;li&gt;proxy: unblind and store the signature in the wallet&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;p&gt;I&#x27;m getting a little anxious about meeting my deadline but I remain focused on forward progress. There are a few hack days built into the berlin conference so I may have a complete demo in time for TAB even if it&#x27;s not working for BTC++. I calm myself with the knowledge that the deadline is artificial and self-imposed. It exists only for motivational purposes.&lt;&#x2F;p&gt;
</content>
        
    </entry>
    <entry xml:lang="en">
        <title>CPU Mining Blinded Secrets</title>
        <published>2024-09-08T00:00:00+00:00</published>
        <updated>2024-09-08T00:00:00+00:00</updated>
        
        <author>
          <name>
            
              vnprc
            
          </name>
        </author>
        
        <link rel="alternate" type="text/html" href="https://hashpool.dev/dev-logs/dev-log-2024-09-08/"/>
        <id>https://hashpool.dev/dev-logs/dev-log-2024-09-08/</id>
        
        <content type="html" xml:base="https://hashpool.dev/dev-logs/dev-log-2024-09-08/">&lt;p&gt;This week I had three wins:&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;began generating blinded secrets upon share submission&lt;&#x2F;li&gt;
&lt;li&gt;ported my work from the benchmarking tool to the real Sv2 project&lt;&#x2F;li&gt;
&lt;li&gt;got it working with a cpu miner&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;p&gt;I added my fork of cdk as a dependency to the Sv1 proxy and started generating blinded secrets on share submission. I got this working on &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;vnprc&#x2F;benchmarking-tool&#x2F;tree&#x2F;hashpool-demo&quot;&gt;my fork of the benchmarking tool&lt;&#x2F;a&gt; and realized that in order to sign the blinded secrets the next step would involve modifying solo pool, which is written in typescript. There is a typescript cashu library in active development but I don&#x27;t think the benefits of using the benchmarking tool outweigh the complexity of adding more codebases in different languages. I realized that I could drop the benchmarking tool and just run Sv2 daemons directly to keep all development within the Sv2 and cdk projects. I have been looking for a hacky shortcut since I started this project and this week I realized that the &#x27;right&#x27; way to build it is actually the shortest path to my goal.&lt;&#x2F;p&gt;
&lt;p&gt;I found this awesome &lt;a href=&quot;https:&#x2F;&#x2F;stratumprotocol.org&#x2F;getting-started&#x2F;&quot;&gt;getting started guide&lt;&#x2F;a&gt; and using the easy mode instructions I was able to point a CPU miner at the public testnet Sv2 instance. With this stack I ported over my blinded secret code from the simple Sv1 proxy in the benchmarking tool to the &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;vnprc&#x2F;stratum&#x2F;tree&#x2F;hashpool-demo&quot;&gt;Sv2 translator proxy&lt;&#x2F;a&gt;. I fake the stuff the wallet needs from the mint and randomly generate blinded secrets instead of deterministic generation. This let me produce blinded secrets without any extra work to manage the mint state.&lt;&#x2F;p&gt;
&lt;p&gt;I also played with the cpu miner found in those instructions and found that it was easy to get running with the right settings. I can pull 47 megahash on my macbook, which is plenty of juice to generate eHash tokens. The advantage of this setup is that I don&#x27;t need to mess with my bitaxe anymore to produce hashrate. The bitaxe will prove useful for testing the final product but reconfiguring it is very slow and adds a network connection to the critical path that will likely cause problems during a live demo. With the cpu miner I can demo the full system with only my laptop and an internet connection.&lt;&#x2F;p&gt;
&lt;p&gt;You can try it out yourself:&lt;&#x2F;p&gt;
&lt;pre style=&quot;background-color:#2b303b;color:#c0c5ce;&quot;&gt;&lt;code&gt;&lt;span&gt;git clone git@github.com:vnprc&#x2F;stratum.git
&lt;&#x2F;span&gt;&lt;span&gt;cd stratum
&lt;&#x2F;span&gt;&lt;span&gt;git checkout hashpool-demo
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;follow the simple setup instructions found &lt;a href=&quot;https:&#x2F;&#x2F;stratumprotocol.org&#x2F;getting-started&#x2F;#run-job-declarator-client-jdc&quot;&gt;here&lt;&#x2F;a&gt;&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;Run Job Declarator Client (JDC)&lt;&#x2F;li&gt;
&lt;li&gt;Run Translator Proxy&lt;&#x2F;li&gt;
&lt;li&gt;CPU Miner&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;p&gt;I have adjusted the proxy settings to tune the rate of mining shares produced by my CPU to be reasonably fast.&lt;&#x2F;p&gt;
&lt;p&gt;Next week dev goals:&lt;&#x2F;p&gt;
&lt;ol&gt;
&lt;li&gt;adapt my setup to &lt;a href=&quot;https:&#x2F;&#x2F;stratumprotocol.org&#x2F;getting-started&#x2F;#ii-getting-started---running-all-roles&quot;&gt;run all roles&lt;&#x2F;a&gt;
&lt;ul&gt;
&lt;li&gt;The publicly available Sv2 pool was not accepting connections at first. I posted to the stratum discord and gitgab fixed it quickly
but this is a dependency I need to remove for a successful demo.&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;Add a cashu mint to pool
&lt;ul&gt;
&lt;li&gt;it needs to handle keyset generation and signing blinded secrets&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;Find a way to include blinded secrets and signatures in the stratum share submission request and response messages&lt;&#x2F;li&gt;
&lt;li&gt;Combine mint signatures with unblinded secrets to make ecash (aka proofs) and store in the cashu wallet.&lt;&#x2F;li&gt;
&lt;&#x2F;ol&gt;
</content>
        
    </entry>
    <entry xml:lang="en">
        <title>New Dev Log Who Dis?</title>
        <published>2024-08-30T00:00:00+00:00</published>
        <updated>2024-08-30T00:00:00+00:00</updated>
        
        <author>
          <name>
            
              vnprc
            
          </name>
        </author>
        
        <link rel="alternate" type="text/html" href="https://hashpool.dev/dev-logs/dev-log-2024-08-30/"/>
        <id>https://hashpool.dev/dev-logs/dev-log-2024-08-30/</id>
        
        <content type="html" xml:base="https://hashpool.dev/dev-logs/dev-log-2024-08-30/">&lt;p&gt;Gary suggested I create a log of my dev work and share it with y&#x27;all to help ensure I&#x27;m making progress and identify problems or suboptimal decisions early on. Great idea, Gary!&lt;&#x2F;p&gt;
&lt;p&gt;My initial development goal is to hack up a demo project with a mining pool and cashu mint that can generate an ecash token for each mining share submitted. I want something to show off at TABConf to help people grok the concept behind hashpool. It would be so sick if I could generate testnet eHash tokens and give them away at the conference. ü§ô&lt;&#x2F;p&gt;
&lt;p&gt;The architecture is pretty simple at this stage:&lt;&#x2F;p&gt;
&lt;pre style=&quot;background-color:#2b303b;color:#c0c5ce;&quot;&gt;&lt;code&gt;&lt;span&gt;           miner                    mining pool
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;ASIC -&amp;gt; stratum proxy &amp;lt;----------&amp;gt; stratum server 
&lt;&#x2F;span&gt;&lt;span&gt;              ^                          ^
&lt;&#x2F;span&gt;&lt;span&gt;              |                          |
&lt;&#x2F;span&gt;&lt;span&gt;              v                          v
&lt;&#x2F;span&gt;&lt;span&gt;         cashu wallet                cashu mint
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;ol&gt;
&lt;li&gt;ASIC submits mining share&lt;&#x2F;li&gt;
&lt;li&gt;stratum proxy validates mining share and requests blinded secret from cashu wallet&lt;&#x2F;li&gt;
&lt;li&gt;stratum proxy submits the mining share and blinded secret to stratum server&lt;&#x2F;li&gt;
&lt;li&gt;stratum server validates mining share&lt;&#x2F;li&gt;
&lt;li&gt;if validation succeeds stratum server requests cashu mint to sign the blinded secret&lt;&#x2F;li&gt;
&lt;li&gt;stratum server sends signature to stratum proxy&lt;&#x2F;li&gt;
&lt;li&gt;stratum proxy sends signature to cashu wallet&lt;&#x2F;li&gt;
&lt;li&gt;cashu wallet unblinds signature, the combination of unblinded signature and unblinded secret is now an ecash token üéâ&lt;&#x2F;li&gt;
&lt;&#x2F;ol&gt;
&lt;p&gt;Or potentially route the blinded secret to the cashu mint directly:&lt;&#x2F;p&gt;
&lt;ol start=&quot;6&quot;&gt;
&lt;li&gt;cashu mint submits signature directly to cashu wallet&lt;&#x2F;li&gt;
&lt;li&gt;cashu wallet unblinds signature, the combination of unblinded signature and unblinded secret is now an ecash token üéâ&lt;&#x2F;li&gt;
&lt;&#x2F;ol&gt;
&lt;p&gt;I am not sure yet which approach makes the most sense but I&#x27;ll cross that bridge when I get to it.&lt;&#x2F;p&gt;
&lt;p&gt;I struggled to get a docker stack running that includes all the moving pieces I need. First I tried to run the Sv2 benchmarking tool which I stood up easily enough but I found I could only submit stale shares. I asked for help on stratum discord and started on plan B. Plan B was to create a docker container running bitcoind and ckpool. I got it stood up only to learn that testnet3 takes a while to sync and ckpool does not yet support testnet4. At this point I stumbled upon the sv2-workshop repo, which honestly looks perfect for my purposes. Before I could explore this project I got some helpful feedback on the benchmarking tool. It turns out it was rejecting my shares because I had entered a mainnet bitcoin address in the user field instead of a testnet4 address. ü§¶ Once I fixed this dumb mistake I was able to mine with the benchmark docker stack. \o&#x2F; I shelved plans to explore the sv2-workshop project in favor of forward progress.&lt;&#x2F;p&gt;
&lt;p&gt;Next step: create a blinded secret. I &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;vnprc&#x2F;benchmarking-tool&#x2F;tree&#x2F;hashpool-demo&quot;&gt;forked&lt;&#x2F;a&gt; the benchmarking tool repo and added a println statement to the place in the code where I need to generate the blinded secret. At this point I was assuming I could use nutshell to generate blinded secrets so I added a nutshell-wallet and nutshell-mint docker containers. When I went looking for the right API call I realized that nutshell doesn&#x27;t offer the functionality I need. It generates the blinded secret and immediately POSTs it to the mint server. This is neither scalable nor atomic. I want to bundle the cashu network call with the stratum call.&lt;&#x2F;p&gt;
&lt;p&gt;I found the function I need in the moksha rust cashu library. When I tried to add this dependency to the sv2 benchmarking tool I ran into conflicting dependency versions. It seems that moksha is a little out of date. The other cashu rust library, cdk, bundles the blinded secret generation and network call into a single function just like nutshell does. I asked the cashu devs for help and the consensus seems to be that cdk is more actively maintained so I should open a PR to expose the functionality I need. I just pushed this &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;cashubtc&#x2F;cdk&#x2F;pull&#x2F;309&quot;&gt;draft PR&lt;&#x2F;a&gt; out today.&lt;&#x2F;p&gt;
&lt;p&gt;Next week: add cdk as a dependency to my fork of the benchmarking tool and use the new function to generate a blinded secret. Find a way to add the blinded secret to the stratum network call.&lt;&#x2F;p&gt;
&lt;p&gt;Questions: Should I use docker or nix? I&#x27;m not really skilled with either tool but the LLM I queried indicated that docker was better for rapid development.&lt;&#x2F;p&gt;
&lt;p&gt;Is the benchmarking tool the right stack to build on? It has a very simple one-file stratum proxy that I can develop on, which is nice. But there is a lot going on in this docker stack and I definitely don&#x27;t need most of it. The grafana dashboard is sick, though. It will make for an impressive demo if I can pull it off in time.&lt;&#x2F;p&gt;
&lt;p&gt;Am I correct to require the ecash and stratum services share a single network call? The potential for error conditions for two different network calls makes my head hurt. That is not a design I think will be successful long-term. Does it matter at this point? One goal of building this demo is to quickly identify architectural challenges and settle on the best design. It seems wrong to make obvious mistakes at this point. I&#x27;m trying to find the non-obvious mistakes.&lt;&#x2F;p&gt;
&lt;p&gt;I am not very familiar with the stratum protocol. Is there a field or something where I can stuff some extra data?&lt;&#x2F;p&gt;
</content>
        
    </entry>
</feed>
